<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>ShakeCraft v5.0: GYRO FIX</title>
    <link href="https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Roboto+Mono:wght@500&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; }
        body { 
            margin: 0; overflow: hidden; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
            font-family: 'Roboto Mono', monospace; user-select: none; touch-action: none; 
        }
        
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
            z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white; text-align: center;
        }
        .title { font-family: 'Black Ops One'; font-size: 48px; color: #fff; margin-bottom: 10px; }
        .btn-start {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            border: none; color: white; padding: 18px 50px; font-size: 22px; 
            font-family: 'Black Ops One'; border-radius: 50px; cursor: pointer;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: none; flex-direction: column; justify-content: space-between; z-index: 10;
        }
        .header { padding: 25px; display: flex; justify-content: space-between; }
        .stat-box { 
            background: rgba(255,255,255,0.2); backdrop-filter: blur(10px);
            color: white; padding: 10px 20px; border-radius: 20px; font-weight: bold;
            display: flex; align-items: center; gap: 10px;
        }

        .tap-zone {
            position: absolute; top: 0; height: 100%; width: 50%;
            pointer-events: auto; z-index: 5; opacity: 0;
        }
        .tap-left { left: 0; background: rgba(255,255,255,0.1); }
        .tap-right { right: 0; background: rgba(255,255,255,0.1); }
        .active-zone { opacity: 1; transition: opacity 0.1s; }

        #sensor-debug {
            position: absolute; bottom: 10px; left: 10px; right: 10px;
            background: rgba(0,0,0,0.8); color: #0f0; font-size: 11px;
            padding: 10px; border-radius: 8px; font-family: monospace;
            pointer-events: none; max-height: 150px; overflow: hidden;
        }

        /* –ö–Ω–æ–ø–∫–∞ –¥–ª—è —Ç–µ—Å—Ç–∞ */
        #manual-shake-btn {
            pointer-events: auto; background: #ff9800; color: white; border: none;
            padding: 10px 20px; border-radius: 20px; font-weight: bold;
            position: absolute; bottom: 180px; left: 50%; transform: translateX(-50%);
            z-index: 20; opacity: 0.8;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="start-screen">
        <div class="title">SHAKE CRAFT</div>
        <p style="color: #ddd;">v5.0 GYRO FIX</p>
        <button class="btn-start" id="startBtn">START GAME</button>
    </div>

    <div id="ui-layer">
        <div class="header">
            <div class="stat-box">üèóÔ∏è <span id="floor-cnt">0</span></div>
            <div class="stat-box">üíé <span id="gem-cnt">10</span></div>
        </div>
        
        <!-- –¢–ï–°–¢–û–í–ê–Ø –ö–ù–û–ü–ö–ê (–µ—Å–ª–∏ –¥–∞—Ç—á–∏–∫–∏ –≤–æ–æ–±—â–µ –Ω–µ —Ä–∞–±–æ—Ç–∞—é—Ç) -->
        <button id="manual-shake-btn" onclick="manualShake()">TEST SHAKE</button>
    </div>

    <div class="tap-zone tap-left" id="z-left"></div>
    <div class="tap-zone tap-right" id="z-right"></div>

    <div id="sensor-debug">Waiting...</div>

    <script>
        // ===== LOGGING =====
        const debugEl = document.getElementById('sensor-debug');
        const logs = [];
        function addLog(msg) {
            logs.push(msg);
            if (logs.length > 6) logs.shift();
            debugEl.innerText = logs.join('\n');
        }

        // ===== CONFIG =====
        const CFG = {
            layerSize: 5,
            gravity: 0.00002,
            gravityAfterShake: 0.000008,
            repairPower: 0.002,
            shakeThresholdAccel: 15,  // –ê–∫—Å–µ–ª–µ—Ä–æ–º–µ—Ç—Ä (–º/—Å¬≤)
            shakeThresholdGyro: 50,   // –ì–∏—Ä–æ—Å–∫–æ–ø (–≥—Ä–∞–¥—É—Å—ã/—Å–µ–∫)
            cooldown: 400
        };

        const STATE = {
            floors: [],
            gems: 10,
            bendVelocity: 0,
            currentBend: 0,
            isPlaying: false,
            isShakingNow: false,
            lastBuild: 0
        };

        // ===== THREE.JS =====
        let scene, camera, renderer;
        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf5f7fa);
            scene.fog = new THREE.Fog(0xf5f7fa, 2, 200);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 500);
            camera.position.set(0, 12, 40);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
            dirLight.position.set(30, 60, 30);
            dirLight.castShadow = true;
            scene.add(dirLight);
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));

            const ground = new THREE.Mesh(new THREE.PlaneGeometry(300, 300), new THREE.MeshStandardMaterial({ color: 0xe8e8e8 }));
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
        }

        // ===== GAME LOGIC =====
        const matBlock = new THREE.MeshStandardMaterial({ color: 0xf5576c });
        const matStone = new THREE.MeshStandardMaterial({ color: 0x667eea });

        function addFloor(isBase = false) {
            const group = new THREE.Group();
            const size = CFG.layerSize;
            const offset = Math.floor(size / 2);
            const mat = isBase ? matStone : matBlock;

            for (let x = 0; x < size; x++) {
                for (let z = 0; z < size; z++) {
                    if (!isBase && x > 0 && x < 4 && z > 0 && z < 4) continue;
                    const geo = new THREE.BoxGeometry(0.9, 0.9, 0.9);
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.set(x - offset, 0, z - offset);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    group.add(mesh);
                }
            }
            STATE.floors.push(group);
            scene.add(group);
            if (!isBase) STATE.gems++;
            
            document.getElementById('floor-cnt').innerText = STATE.floors.length;
            document.getElementById('gem-cnt').innerText = STATE.gems;
        }

        function onShake() {
            if (Date.now() - STATE.lastBuild > CFG.cooldown) {
                addLog('>>> SHAKE ACTION! <<<');
                addFloor();
                STATE.lastBuild = Date.now();
                STATE.isShakingNow = true;
                setTimeout(() => STATE.isShakingNow = false, CFG.cooldown + 200);
                STATE.bendVelocity += (Math.random() - 0.5) * 0.0002;
            }
        }

        window.manualShake = function() {
            addLog('Manual Button Clicked');
            onShake();
        };

        // ===== SENSORS (DUAL MODE) =====
        let lastX=0, lastY=0, lastZ=0;
        let lastAlpha=0, lastBeta=0, lastGamma=0;

        // 1. ACCELEROMETER (DeviceMotion)
        function handleMotion(e) {
            const acc = e.accelerationIncludingGravity;
            if (!acc) return;

            const force = Math.abs(acc.x) + Math.abs(acc.y) + Math.abs(acc.z);
            // –ü—Ä–æ—Å—Ç–æ –≤—ã–≤–æ–¥–∏–º –¥–∞–Ω–Ω—ã–µ –≤ –ª–æ–≥ —Ä–∞–∑ –≤ —Å–µ–∫—É–Ω–¥—É –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
            if (Math.random() < 0.05) addLog(`Accel Force: ${force.toFixed(1)}`);

            if (force > CFG.shakeThresholdAccel) {
                onShake();
            }
        }

        // 2. GYROSCOPE (DeviceOrientation) - –ó–∞–ø–∞—Å–Ω–æ–π –≤–∞—Ä–∏–∞–Ω—Ç
        function handleOrientation(e) {
            // alpha (z), beta (x), gamma (y)
            if (!e.alpha) return;

            const dAlpha = Math.abs(e.alpha - lastAlpha);
            const dBeta = Math.abs(e.beta - lastBeta);
            const dGamma = Math.abs(e.gamma - lastGamma);

            // –§–∏–ª—å—Ç—Ä—É–µ–º —Å–∫–∞—á–∫–∏ —á–µ—Ä–µ–∑ 360 –≥—Ä–∞–¥—É—Å–æ–≤
            if (dAlpha > 300) return; 

            const rotationSpeed = dAlpha + dBeta + dGamma;
            
            if (Math.random() < 0.05) addLog(`Gyro Speed: ${rotationSpeed.toFixed(1)}`);

            if (rotationSpeed > CFG.shakeThresholdGyro) {
                onShake();
            }

            lastAlpha = e.alpha;
            lastBeta = e.beta;
            lastGamma = e.gamma;
        }

        // ===== PHYSICS LOOP =====
        function updatePhysics() {
            const h = STATE.floors.length;
            if (h < 2) return;

            let g = STATE.isShakingNow ? CFG.gravityAfterShake : CFG.gravity;
            let leverage = h * 0.00005;
            
            if (STATE.currentBend > 0) STATE.bendVelocity += g * leverage;
            else STATE.bendVelocity -= g * leverage;

            STATE.bendVelocity *= 0.98;
            STATE.currentBend += STATE.bendVelocity;
            STATE.currentBend = Math.max(-0.5, Math.min(0.5, STATE.currentBend));

            let accumulatedAngle = 0;
            let bendPerFloor = STATE.currentBend * 0.8;
            let pos = new THREE.Vector3(0, 0, 0);
            let up = new THREE.Vector3(0, 1, 0);

            for (let i = 0; i < h; i++) {
                const f = STATE.floors[i];
                f.position.copy(pos);
                f.rotation.z = -accumulatedAngle;
                let dir = up.clone().applyAxisAngle(new THREE.Vector3(0, 0, 1), -accumulatedAngle);
                pos.add(dir);
                accumulatedAngle += bendPerFloor;
            }

            const topPos = STATE.floors[h-1].position.clone();
            const midX = topPos.x / 2;
            const midY = topPos.y / 2 + 5;
            const targetZ = 40 + (h * 1.8);

            camera.position.x += (midX - camera.position.x) * 0.04;
            camera.position.y += (midY - camera.position.y) * 0.04;
            camera.position.z += (targetZ - camera.position.z) * 0.04;
            camera.lookAt(midX, midY, 0);
        }

        function loop() {
            requestAnimationFrame(loop);
            updatePhysics();
            renderer.render(scene, camera);
        }

        // ===== START =====
        async function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('ui-layer').style.display = 'flex';
            STATE.isPlaying = true;
            addFloor(true);

            // Try Sensors
            if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                try {
                    const resp = await DeviceMotionEvent.requestPermission();
                    if (resp === 'granted') {
                        window.addEventListener('devicemotion', handleMotion, true);
                        window.addEventListener('deviceorientation', handleOrientation, true);
                        addLog('iOS Sensors ON');
                    }
                } catch (e) { addLog('iOS Perm Error'); }
            } else {
                window.addEventListener('devicemotion', handleMotion, true);
                window.addEventListener('deviceorientation', handleOrientation, true);
                addLog('Android Sensors ON');
            }

            loop();
        }

        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('z-left').addEventListener('pointerdown', (e) => { e.preventDefault(); STATE.bendVelocity += CFG.repairPower; });
        document.getElementById('z-right').addEventListener('pointerdown', (e) => { e.preventDefault(); STATE.bendVelocity -= CFG.repairPower; });

        initThree();

    </script>
</body>
</html>
